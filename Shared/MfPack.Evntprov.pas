// FactoryX
//
// Copyright: © FactoryX. All rights reserved.
//
// Project: MfPack - Shared
// Project location: https://sourceforge.net/projects/MFPack
// Module: MfPack.Evntprov.pas
// Kind: Pascal / Delphi unit
// Release date: 18-12-2016
// Language: ENU
//
// Revision Version: 2.6.4
// Description: This defines the unified provider side user mode API.
//
// Organisation: FactoryX
// Initiator(s): Tony (maXcomX), Peter (OzShips)
// Contributor(s): Tony Kalf (maXcomX),
//
//------------------------------------------------------------------------------
// CHANGE LOG
// Date       Person              Reason
// ---------- ------------------- ----------------------------------------------
// 28/05/2020                     Kraftwerk release. (WIN10 April 2020 update, version 20H1)
//------------------------------------------------------------------------------
//
// Remarks: Requires Windows Vista or later.
// 
// Related objects: -
// Related projects: MfPackX264
// Known Issues: -
//
// Compiler version: 23 up to 33
// SDK version: 10.0.19569.0
//
// Todo: -
//
//==============================================================================
// Source: evntprov.h
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//==============================================================================
//
// LICENSE
// 
// The contents of this file are subject to the Mozilla Public License
// Version 2.0 (the "License"); you may not use this file except in
// compliance with the License. You may obtain a copy of the License at
// https://www.mozilla.org/en-US/MPL/2.0/
// 
// Software distributed under the License is distributed on an "AS IS"
// basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
// License for the specific language governing rights and limitations
// under the License.
// 
// Users may distribute this source code provided that this header is included
// in full at the top of the file.
//==============================================================================
unit MfPack.EvntProv;

  {$HPPEMIT ''}
  {$HPPEMIT '#include "evntprov.h"'}
  {$HPPEMIT ''}

interface

uses

  {Winapi}
  Winapi.Windows,
  {MfPack}
  MfPack.MfpTypes;

  {$WEAKPACKAGEUNIT ON}
  {$MINENUMSIZE 4}

  {$IFDEF WIN32}
    {$ALIGN 1}
  {$ELSE}
    {$ALIGN 8} // Win64
  {$ENDIF}

  {$I 'MfPack.inc'}

const

  EVENT_MIN_LEVEL                     = 0;    // Lowest value for an event level is 0.
  {$EXTERNALSYM EVENT_MIN_LEVEL}
  EVENT_MAX_LEVEL                     = $FF;  // Highest value for an event level is 255.
  {$EXTERNALSYM EVENT_MAX_LEVEL}


  // EVENT_ACTIVITY_CTRL values for the ControlCode parameter of
  // EventActivityIdControl.

  EVENT_ACTIVITY_CTRL_GET_ID          = 1;
  {$EXTERNALSYM EVENT_ACTIVITY_CTRL_GET_ID}
    { EventActivityIdControl will return the current thread's activity ID. }

  EVENT_ACTIVITY_CTRL_SET_ID          = 2;
  {$EXTERNALSYM EVENT_ACTIVITY_CTRL_SET_ID}
    { EventActivityIdControl will set the current thread's activity ID. }

  EVENT_ACTIVITY_CTRL_CREATE_ID       = 3;
  {$EXTERNALSYM EVENT_ACTIVITY_CTRL_CREATE_ID}
    { EventActivityIdControl will generate and return a new activity ID. Note
    that the returned activity ID is not a GUID. The EventActivityIdControl
    function uses a faster generation algorithm than UuidCreate. The returned
    ID is guaranteed to be different from any valid GUID and different from any
    other activity ID generated by EventActivityIdControl on the same machine
    during the same boot session. }

  EVENT_ACTIVITY_CTRL_GET_SET_ID      = 4;
  {$EXTERNALSYM EVENT_ACTIVITY_CTRL_GET_SET_ID}
    { EventActivityIdControl will set the current thread's activity ID and
    return the previous activity ID. }

  EVENT_ACTIVITY_CTRL_CREATE_SET_ID   = 5;
  {$EXTERNALSYM EVENT_ACTIVITY_CTRL_CREATE_SET_ID}
    { EventActivityIdControl will generate a new activity ID, set the current
    thread's activity ID to the new value, and return the previous activity
    ID. }

  MAX_EVENT_DATA_DESCRIPTORS          = 128;
  {$EXTERNALSYM MAX_EVENT_DATA_DESCRIPTORS}
    { The maximum number of EVENT_DATA_DESCRIPTORs that can be used in an event.
    Used with EventWrite, EventWriteTransfer, EventWriteEx. }

  MAX_EVENT_FILTER_DATA_SIZE          = 1024;
  {$EXTERNALSYM MAX_EVENT_FILTER_DATA_SIZE}
  { The maximum data size for many of the filter types.
    Used with EVENT_FILTER_DESCRIPTOR. }

  MAX_EVENT_FILTER_PAYLOAD_SIZE       = 4096;
  {$EXTERNALSYM MAX_EVENT_FILTER_PAYLOAD_SIZE}
  { The maximum data size for an event payload filter.
    Used with EVENT_FILTER_DESCRIPTOR of type EVENT_FILTER_TYPE_PAYLOAD. }

  MAX_EVENT_FILTER_EVENT_NAME_SIZE    = 4096;
  {$EXTERNALSYM MAX_EVENT_FILTER_EVENT_NAME_SIZE}
  { The maximum data size for a name-based filter.
    Used with EVENT_FILTER_DESCRIPTOR for name-based filters. }

  MAX_EVENT_FILTERS_COUNT             = 13;
  {$EXTERNALSYM MAX_EVENT_FILTERS_COUNT}
  { The maximum number of filters that can be provided in a call to
    EnableTraceEx2.
    Used with ENABLE_TRACE_PARAMETERS. }

  MAX_EVENT_FILTER_PID_COUNT          = 8;
  {$EXTERNALSYM MAX_EVENT_FILTER_PID_COUNT}
  { The maximum number of process IDs in a PID filter.
    Used with EVENT_FILTER_DESCRIPTOR of type EVENT_FILTER_TYPE_PID. }

  MAX_EVENT_FILTER_EVENT_ID_COUNT     = 64;
  {$EXTERNALSYM MAX_EVENT_FILTER_EVENT_ID_COUNT}
  { The maximum number of event IDs in an event ID or stackwalk filter.
    Used with EVENT_FILTER_DESCRIPTOR of type EVENT_FILTER_TYPE_EVENT_ID or
    EVENT_FILTER_TYPE_STACKWALK. }


  // EVENT_FILTER_TYPE values for the Type field of EVENT_FILTER_DESCRIPTOR.

  EVENT_FILTER_TYPE_NONE               = $00000000;
  {$EXTERNALSYM EVENT_FILTER_TYPE_NONE}
  EVENT_FILTER_TYPE_SCHEMATIZED        = $80000000;  // Provider-side.
  {$EXTERNALSYM EVENT_FILTER_TYPE_SCHEMATIZED}
  EVENT_FILTER_TYPE_SYSTEM_FLAGS       = $80000001;  // Internal use only.
  {$EXTERNALSYM EVENT_FILTER_TYPE_SYSTEM_FLAGS}
  EVENT_FILTER_TYPE_TRACEHANDLE        = $80000002;  // Initiate rundown.
  {$EXTERNALSYM EVENT_FILTER_TYPE_TRACEHANDLE}
  EVENT_FILTER_TYPE_PID                = $80000004;  // Process ID.
  {$EXTERNALSYM EVENT_FILTER_TYPE_PID}
  EVENT_FILTER_TYPE_EXECUTABLE_NAME    = $80000008;  // EXE file name.
  {$EXTERNALSYM EVENT_FILTER_TYPE_EXECUTABLE_NAME}
  EVENT_FILTER_TYPE_PACKAGE_ID         = $80000010;  // Package ID.
  {$EXTERNALSYM EVENT_FILTER_TYPE_PACKAGE_ID}
  EVENT_FILTER_TYPE_PACKAGE_APP_ID     = $80000020;  // Package Relative App Id (PRAID).
  {$EXTERNALSYM EVENT_FILTER_TYPE_PACKAGE_APP_ID}
  EVENT_FILTER_TYPE_PAYLOAD            = $80000100;  // TDH payload filter.
  {$EXTERNALSYM EVENT_FILTER_TYPE_PAYLOAD}
  EVENT_FILTER_TYPE_EVENT_ID           = $80000200;  // Event IDs.
  {$EXTERNALSYM EVENT_FILTER_TYPE_EVENT_ID}
  EVENT_FILTER_TYPE_EVENT_NAME         = $80000400;  // Event name (TraceLogging only).
  {$EXTERNALSYM EVENT_FILTER_TYPE_EVENT_NAME}
  EVENT_FILTER_TYPE_STACKWALK          = $80001000;  // Event IDs for stack.
  {$EXTERNALSYM EVENT_FILTER_TYPE_STACKWALK}
  EVENT_FILTER_TYPE_STACKWALK_NAME     = $80002000;  // Event name for stack (TraceLogging only).
  {$EXTERNALSYM EVENT_FILTER_TYPE_STACKWALK_NAME}
  EVENT_FILTER_TYPE_STACKWALK_LEVEL_KW = $80004000;  // Filter stack collection by level and keyword.
  {$EXTERNALSYM EVENT_FILTER_TYPE_STACKWALK_LEVEL_KW}
  EVENT_FILTER_TYPE_CONTAINER          = $80008000;  // Filter by Container ID.
  {$EXTERNALSYM EVENT_FILTER_TYPE_CONTAINER}


  // EVENT_DATA_DESCRIPTOR_TYPE values for the Type field of EVENT_DATA_DESCRIPTOR.
  // Note that the Type field is ignored by default. ETW will only check the Type
  // field if a provider has opted-in via a call to EventSetInformation.

  EVENT_DATA_DESCRIPTOR_TYPE_NONE              = 0;
  {$EXTERNALSYM EVENT_DATA_DESCRIPTOR_TYPE_NONE}
    { Event data (payload). }

  EVENT_DATA_DESCRIPTOR_TYPE_EVENT_METADATA    = 1;
  {$EXTERNALSYM EVENT_DATA_DESCRIPTOR_TYPE_EVENT_METADATA}
    { TraceLogging event decoding information. }

  EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA = 2;
  {$EXTERNALSYM EVENT_DATA_DESCRIPTOR_TYPE_PROVIDER_METADATA}
    { Manually-attached provider traits. For use with operating systems that do
    not support attaching provider traits via EventSetInformation. This data
    will be ignored if provider traits have been configured via
    EventSetInformation. }

  EVENT_DATA_DESCRIPTOR_TYPE_TIMESTAMP_OVERRIDE = 3;
  {$EXTERNALSYM EVENT_DATA_DESCRIPTOR_TYPE_TIMESTAMP_OVERRIDE}
    { 64-bit event timestamp override. For use when relogging. Note that logging
    events out of timestamp order may lead to event ordering issues during
    trace processing. }


  // EVENT_WRITE_FLAG values for the Flag parameter of EventWriteEx and EtwWriteEx.

  EVENT_WRITE_FLAG_NO_FAULTING                  = $00000001;
  {$EXTERNALSYM EVENT_WRITE_FLAG_NO_FAULTING}
    { EVENT_WRITE_FLAG_NO_FAULTING is used in kernel-mode calls to EtwWriteEx.
    Certain ETW functionality requires paging. ETW will automatically disable
    such functionality when it is called at high IRQL (dispatch or above).
    To call ETW at low IRQL (below dispatch) from a context in which page
    faults are not tolerated, use EtwWriteEx and include this flag. }

  EVENT_WRITE_FLAG_INPRIVATE                    = $00000002;
  {$EXTERNALSYM EVENT_WRITE_FLAG_INPRIVATE}
    { EVENT_WRITE_FLAG_INPRIVATE indicates that an event should be dropped on any
    logger the uses EVENT_ENABLE_PROPERTY_EXCLUDE_INPRIVATE. }


  // A REGHANDLE represents an event provider session.
  // A REGHANDLE is opened with EventRegister and closed with EventUnregister.

type

  PREGHANDLE = ^ULONGLONG;
  REGHANDLE = ULONGLONG;
  {$EXTERNALSYM REGHANDLE}


  // EVENT_DATA_DESCRIPTOR is used with EventWrite to provide user data items.

  PEVENT_DATA_DESCRIPTOR = ^_EVENT_DATA_DESCRIPTOR;
  _EVENT_DATA_DESCRIPTOR = record
    Ptr: ULONGLONG;    // Pointer to data. Set to (ULONGLONG)(ULONG_PTR)pData.
    Size: ULONG;       // Size of data in bytes.
    DUMMYSTRUCTNAME : record
    case Boolean of
      True  : (Reserved: ULONG);  // Set to 0 if not using a special data item type.
      False : (_Type: UCHAR;      // Default is EVENT_DATA_DESCRIPTOR_TYPE_NONE, meaning normal payload data.
               Reserved1: UCHAR;
               Reserved2: USHORT);
    end;
  end;
  {$EXTERNALSYM _EVENT_DATA_DESCRIPTOR}
  EVENT_DATA_DESCRIPTOR = _EVENT_DATA_DESCRIPTOR;
  {$EXTERNALSYM EVENT_DATA_DESCRIPTOR}

//#ifndef EVENT_DESCRIPTOR_DEF
//#define EVENT_DESCRIPTOR_DEF


  // EVENT_DESCRIPTOR describes and categorizes an event.
  // Note that for TraceLogging events, the Id and Version fields are not
  // meaningful and should be ignored.


  PEVENT_DESCRIPTOR = ^_EVENT_DESCRIPTOR;
  PCEVENT_DESCRIPTOR = ^_EVENT_DESCRIPTOR;
  _EVENT_DESCRIPTOR = record
    Id : USHORT;                      {
    For manifest-based events, the Provider.Guid + Event.Id + Event.Version
    should uniquely identify an event. Once a manifest with a particular
    event Id+Version has been made public, the definition of that event
    (the types, ordering, and semantics of the fields) should never be
    changed. If an event needs to be changed, it must be given a new
    identity (usually by incrementing the Version), and the original event
    must remain in the manifest (so that older versions of the event can
    still be decoded with the new manifest). To change an event (e.g. to
    add/remove a field or to change a field type): duplicate the event in
    the manifest, then increment the event Version and make changes in the
    new copy.
    For manifest-free events (i.e. TraceLogging), Event.Id and
    Event.Version are not useful and should be ignored. Use Event name,
    level, keyword, and opcode for event filtering and identification. }
    Version : UCHAR;                  {
    For manifest-based events, the Provider.Guid + Event.Id + Event.Version
    should uniquely identify an event. The Id+Version constitute a 24-bit
    identifier. Generally, events with the same Id are semantically
    related, and the Version is incremented as the event is refined over
    time. }
    Channel : UCHAR;                  {
    The meaning of the Channel field depends on the event consumer.
    This field is most commonly used with events that will be consumed by
    the Windows Event Log. Note that Event Log does not listen to all ETW
    events, so setting a channel is not enough to make the event appear in
    the Event Log. For an ETW event to be routed to Event Log, the
    following must be configured:
    - The provider and its channels must be defined in a manifest.
    - The manifest must be compiled with the mc.exe tool, and the resulting
    BIN files must be included into the resources of an EXE or DLL.
    - The EXE or DLL containing the BIN data must be installed on the
    machine where the provider will run.
    - The manifest must be registered (using wevtutil.exe) on the machine
    where the provider will run. The manifest registration process must
    record the location of the EXE or DLL with the BIN data.
      - The channel must be enabled in Event Log configuration.
      - The provider must log an event with the channel and keyword set
      correctly as defined in the manifest. (Note that the mc.exe code
      generator will automatically define an implicit keyword for each
      channel, and will automatically add the channel's implicit keyword to
      each event that references a channel.) }
      Level : UCHAR;                  {
      The event level defines the event's severity or importance and is a
      primary means for filtering events. Microsoft-defined levels (in
      evntrace.h and  winmeta.h) are 1 (critical/fatal), 2 (error),
      3 (warning), 4 (information), and 5 (verbose). Levels 6-9 are reserved.
      Level 0 means the event is always-on (will not be filtered by level).
      For a provider, a lower level means the event is more important. An
      event with level 0 will always pass any level-based filtering.
      For a consumer, a lower level means the session's filter is more
      restrictive. However, setting a session's level to 0 disables level
      filtering (i.e. session level 0 is the same as session level 255). }
      Opcode : UCHAR;                 {
      The event opcode is used to mark events with special semantics that
      may be used by event decoders to organize and correlate events.
      Globally-recognized opcode values are defined in winmeta.h. A provider
      can define its own opcodes. Most events use opcode 0 (information).
      The opcodes 1 (start) and 2 (stop) are used to indicate the beginning
      and end of an activity as follows:
      - Generate a new activity Id (UuidCreate or EventActivityIdControl).
      - Write an event with opcode = start, activity ID = (the generated
      activity ID), and related activity ID = (the parent activity if any).
      - Write any number of informational events with opcode = info, activity
      ID = (the generated activity ID).
      - Write a stop event with opcode = stop, activity ID = (the generated
      activity ID).
      Each thread has an implicit activity ID (in thread-local storage) that
      will be applied to any event that does not explicitly specify an
      activity ID. The implicit activity ID can be accessed using
      EventActivityIdControl. It is intended that the thread-local activity
      will be used to implement scope-based activities: on entry to a scope
      (i.e. at the start of a function), a user will record the existing
        value of the implicit activity ID, generate and set a new value, and
        write a start event; on exit from the scope, the user will write a stop
        event and restore the previous activity ID. Note that there is no enforcement
        of this pattern, and an application must be aware that other code may
        potentially overwrite the activity ID without restoring it. In
        addition, the implicit activity ID does not work well with cross-thread
        activities. For these reasons, it may be more appropriate to use
        explicit activity IDs (explicitly pass a GUID to EventWriteTransfer)
        instead of relying on the implicity activity ID. }
        Task : USHORT;                {
        The event task code can be used for any purpose as defined by the
        provider. The task code 0 is the default, used to indicate that no
        special task code has been assigned to the event. The ETW manifest
        supports assigning localizable strings for each task code. The task
        code might be used to group events into categories, or to simply
        associate a task name with each event. }
        Keyword : ULONGLONG;         {
        The event keyword defines membership in various categories and is an
        important means for filtering events. The event's keyword is a set of
        64 bits indicating the categories to which an event belongs. The
        provider manifest may provide definitions for up to 48 keyword values,
        each value defining the meaning of a single keyword bit (the upper 16
        bits are reserved by Microsoft for special purposes). For example, if
        the provider manifest defines keyword 0x0010 as "Networking", and
        defines keyword 0x0020 as "Threading", an event with keyword 0x0030
        would be in both "Networking" and "Threading" categories, while an
        event with keyword 0x0001 would be in neither category. An event with
        keyword 0 is treated as uncategorized.
        Event consumers can use keyword masks to determine which events should
        be included in the log. A session can define a KeywordAny mask and
        a KeywordAll mask. An event will pass the session's keyword filtering
        if the following expression is true:
        event.Keyword == 0 || (
        (event.Keyword  session.KeywordAny) != 0
        (event.Keyword  session.KeywordAll) == session.KeywordAll).
        In other words, uncategorized events (events with no keywords set)
        always pass keyword filtering, and categorized events pass if they
        match any keywords in KeywordAny and match all keywords in KeywordAll.
        }
      end;
  {$EXTERNALSYM _EVENT_DESCRIPTOR}
  EVENT_DESCRIPTOR = _EVENT_DESCRIPTOR;
  {$EXTERNALSYM EVENT_DESCRIPTOR}

  // EVENT_FILTER_DESCRIPTOR describes a filter data item for EnableTraceEx2.

  PEVENT_FILTER_DESCRIPTOR = ^_EVENT_FILTER_DESCRIPTOR;
  _EVENT_FILTER_DESCRIPTOR = record
    Ptr   : ULONGLONG;                  // Pointer to filter data. Set to (ULONGLONG)(ULONG_PTR)pData.
    Size  : ULONG;                      // Size of filter data in bytes.
    _Type : ULONG;                      // EVENT_FILTER_TYPE value.
  end;
  {$EXTERNALSYM _EVENT_FILTER_DESCRIPTOR}
  EVENT_FILTER_DESCRIPTOR = _EVENT_FILTER_DESCRIPTOR;
  {$EXTERNALSYM EVENT_FILTER_DESCRIPTOR}


  // Defines the header data that must precede the filter data.
  // The filter data layout is defined in the instrumentation manifest.

  PEVENT_FILTER_HEADER = ^_EVENT_FILTER_HEADER;
  _EVENT_FILTER_HEADER = record
    Id         : USHORT;
    Version    : UCHAR;
    Reserved   : array [0..4] of UCHAR;
    InstanceId : ULONGLONG;
    Size       : ULONG;
    NextOffset : ULONG;
  end;
  {$EXTERNALSYM _EVENT_FILTER_HEADER}
  EVENT_FILTER_HEADER = _EVENT_FILTER_HEADER;
  {$EXTERNALSYM EVENT_FILTER_HEADER}


  // EVENT_FILTER_EVENT_ID is used to pass EventId filter for
  // stack walk filters.

  PEVENT_FILTER_EVENT_ID = ^EVENT_FILTER_EVENT_ID;
  _EVENT_FILTER_EVENT_ID = record
    FilterIn : BOOL;
    Reserved : UCHAR;
    Count    : USHORT;
    Events   : array [0..ANYSIZE_ARRAY - 1] of USHORT;
  end;
  {$EXTERNALSYM _EVENT_FILTER_EVENT_ID}
  EVENT_FILTER_EVENT_ID = _EVENT_FILTER_EVENT_ID;
  {$EXTERNALSYM EVENT_FILTER_EVENT_ID}


  // EVENT_FILTER_EVENT_NAME is used to pass the EventName filter.

  // This filter will only be applied to events that are otherwise enabled
  // on the logging session (via level/keyword in the enable call).

  // The Level, MatchAnyKeyword, and MatchAllKeyword fields in the filter
  // determine which of those otherwise enabled events the filter is applied to.

  // FilterIn determines whether the events matching the provided names will be
  // filtered in or filtered out.  When used for the EVENT_FILTER_TYPE_STACKWALK_NAME
  // filter type, the filtered in events will have stacks collected for them.

  // The Names field should be a series of NameCount nul-terminated utf-8
  // event names.

  PEVENT_FILTER_EVENT_NAME = ^EVENT_FILTER_EVENT_NAME;
  _EVENT_FILTER_EVENT_NAME = record
    MatchAnyKeyword : ULONGLONG;
    MatchAllKeyword : ULONGLONG;
    Level           : UCHAR;
    FilterIn        : BOOL;
    NameCount       : USHORT;
    Names           : array [0..ANYSIZE_ARRAY - 1] of UCHAR;  // utf-8
  end;
  {$EXTERNALSYM _EVENT_FILTER_EVENT_NAME}
  EVENT_FILTER_EVENT_NAME = _EVENT_FILTER_EVENT_NAME;
  {$EXTERNALSYM EVENT_FILTER_EVENT_NAME}


  // EVENT_FILTER_LEVEL_KW is used to pass the StackWalk Level-Keyword filter.

  // This filter will only be applied to events that are otherwise enabled
  // on the logging session (via level/keyword in the enable call).

  // The Level, MatchAnyKeyword, and MatchAllKeyword fields in the filter
  // determine which of these events should have the filter applied to it.

  // FilterIn determines whether the events matching the provided names will be
  // filtered in or filtered out.  Those filtered in will have Stacks collected.

  PEVENT_FILTER_LEVEL_KW = ^EVENT_FILTER_LEVEL_KW;
  _EVENT_FILTER_LEVEL_KW = record
    MatchAnyKeyword : ULONGLONG;
    MatchAllKeyword : ULONGLONG;
    Level           : UCHAR;
    FilterIn        : BOOL;
  end;
  {$EXTERNALSYM _EVENT_FILTER_LEVEL_KW}
  EVENT_FILTER_LEVEL_KW = _EVENT_FILTER_LEVEL_KW;
  {$EXTERNALSYM EVENT_FILTER_LEVEL_KW}


  // EVENT_INFO_CLASS values for the InformationClass parameter of
  // EventSetInformation.

  PEVENT_INFO_CLASS = ^_EVENT_INFO_CLASS;
  _EVENT_INFO_CLASS = (
    EventProviderBinaryTrackInfo,    {
    Requests that the ETW runtime add the full path to the binary that
    registered the provider into each trace. The full path is important if
    if the binary contains the mc.exe-generated decoding resources but is
    not globally registered. Decoding tools can use the path to locate the
    binary and extract the decoding resources. }
    EventProviderSetReserved1,       {
    Not used. }
    EventProviderSetTraits,          {
    Provides the ETW runtime with additional information about the
    provider, potentially including the provider name and a group GUID.
    Refer the the MSDN Provider Traits topic for more information about the
    format of the data to be used with this control code.
    Setting this trait also configures the ETW runtime to respect the
    Type field of EVENT_DATA_DESCRIPTOR (by default the Type field is
    ignored). }
    EventProviderUseDescriptorType,  {
    Configures whether the ETW runtime should respect the Type field of the
    EVENT_DATA_DESCRIPTOR. The data for this control code is a BOOLEAN
    (1 byte, value FALSE or TRUE). }
    MaxEventInfo);
  {$EXTERNALSYM _EVENT_INFO_CLASS}
  EVENT_INFO_CLASS = _EVENT_INFO_CLASS;
  {$EXTERNALSYM EVENT_INFO_CLASS}



  // Optional callback function that users provide to EventRegister.
  // (Refer to MSDN documentation for EnableCallback.)

  // The ETW runtime will invoke this function to send notifications to a provider.
  // These notifications include the following values of the IsEnabled parameter:

  // - EVENT_CONTROL_CODE_DISABLE_PROVIDER (0): No sessions are listening for events
  //   from this provider.
  // - EVENT_CONTROL_CODE_ENABLE_PROVIDER (1): At least one session is listening for
  //   events from this provider. This notification may be sent multiple times if
  //   multiple different providers are listening, if a provider changes its level
  //   or keyword masks, or if a provider updates its filter data.
  // - EVENT_CONTROL_CODE_CAPTURE_STATE (2): A session is requesting that this
  //   provider log its state.

  // Note that for the ENABLE_PROVIDER and CAPTURE_STATE notifications, the ETW
  // runtime will adjust the Level, MatchAnyKeyword, and MatchAllKeyword parameters
  // to the least-restrictive values set by any subscribed session. The callback is
  // not responsible for maintaining these values on a per-session basis.
  //
  // The provider can use these notifications to perform efficient event filtering.
  // While such filtering is optional (the ETW runtime will perform the same
  // filtering), filtering within the provider is usually much more efficient than
  // relying on ETW's internal filtering. Filtering within the provider usually
  // means checking a few global variables and can be done before preparing the
  // data to be sent to ETW. ETW's internal filtering always occurs after the data
  // has been prepared, and it requires looking up the provider's handle in a table.

  // The provider can use the CAPTURE_STATE notification to log non-event
  // information (such as performance counters or system status) on-demand.
  // If the provider has no such state, it can ignore any CAPTURE_STATE events.

  // Assuming that the callback saves the values of IsEnabled, Level,
  // MatchAnyKeyword, and MatchAllKeyword in global variables each time a
  // DISABLE_PROVIDER or ENABLE_PROVIDER notification occurs, an event would be
  // filtered as follows:

  // if (g_IsEnabled != 0 &&       // Provider is enabled
  //     event.Level <= g_Level && // Event passes level filter
  //     (event.Keyword == 0 || (  // Event is uncategorized or passes keyword filter
  //      (event.Keyword & g_MatchAnyKeyword) != 0 &&
  //      (event.Keyword & g_MatchAllKeyword) == g_MatchAllKeyword)))
  // {
  //     PrepareEventData(...);
  //     EventWrite(...);
  // }

  // Note that the code generated by mc.exe includes an efficient callback routine
  // and optimized event filtering system that implements the behavior described
  // above. The mc.exe-generated callback will be registered if you use the
  // mc.exe-generated EventRegister[ProviderName] macro to register the provider.
  // Similarly, when using TraceLoggingProvider.h, TraceLoggingRegister will
  // install its own callback routine so that it can efficiently filter each
  // TraceLoggingWrite event.

  // If filtering performance is not critical, but you still want to avoid
  // preparing data unnecessarily, you can eliminate the need for a callback by
  // using the EventEnabled or EventProviderEnabled routines. These routines still
  // require ETW to perform a table lookup, but they can help you avoid the overhead
  // of preparing your data without needing to register a callback. In that case,
  // the above code would be replaced with something like this:

  // if (EventProviderEnabled(regHandle, event.Level, event.Keyword))
  // {
  //     PrepareEventData(...);
  //     EventWrite(...);
  // }


  PENABLECALLBACK = function(const SourceId: TGUID;
                             IsEnabled: ULONG;
                             Level: INT; //UCHAR
                             MatchAnyKeyword: ULONGLONG;
                             MatchAllKeyword: ULONGLONG;
                             FilterData: PEVENT_FILTER_DESCRIPTOR;
                             CallbackContext: PVOID): ULONG; stdcall;
  {$EXTERNALSYM PENABLECALLBACK}


  // Registration APIs
  // =================

// #if (WINVER >= _WIN32_WINNT_VISTA)


  // Registers a provider with the ETW runtime and obtains a handle to use with
  // calls to EventWrite.

  // Note that the returned RegHandle must be closed by calling EventUnregister.
  // This is especially important if the provider is registered by DLL. If the DLL
  // unloads without closing the handle, the process may crash when the ETW runtime
  // attempts to invoke the provider's callback after the has unloaded.


  function EventRegister(const ProviderId: TGUID;
                         EnableCallback: PENABLECALLBACK;
                         CallbackContext: Pointer;
                         out RegHandle: REGHANDLE): ULONG; stdcall;
  {$EXTERNALSYM EventRegister}


//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Closes the RegHandle that was opened by EventRegister.


  function EventUnregister(RegHandle: REGHANDLE): ULONG; stdcall;
  {$EXTERNALSYM EventUnregister}



//#if (WINVER >= _WIN32_WINNT_WIN8)

  // Used to provide the ETW runtime with additional information about your provider
  // or to configure how the ETW runtime handles your provider's events.
  // Refer to the documentation of the EVENT_INFO_CLASS for more information.


  function EventSetInformation(const RegHandle: REGHANDLE;
                               const InformationClass: EVENT_INFO_CLASS;
                               const EventInformation: Pointer;
                               const InformationLength: ULONG): ULONG; stdcall;
  {$EXTERNALSYM EventSetInformation}


//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Used to check whether any sessions are enabled to receive an event with the
  // Level and Keyword specified in the given EventDescriptor.

  // Note that this function is not as efficient as the checks built into most
  // ETW frameworks (e.g. the checks implemented by mc.exe's generated code or by
  // TraceLoggingProvider.h). This function must look up the RegHandle state, while
  // the ETW frameworks can usually perform a direct check against global variables.
  // If using an ETW framework, use the framework's test APIs in preference to this
  // function.

  // This function can be used to avoid performing expensive preparation before
  // calling EventWrite, i.e. to avoid spending CPU cycles looking up data and
  // packing it into EVENT_DATA_DESCRIPTORs.

  // This is a good idea if PrepareEventData(...) is expensive:
  // if (EventEnabled(regHandle, &myEventDesc))
  // {
  //     PrepareEventData(...);
  //     EventWrite(regHandle, &myEventDesc, ...);
  // }

  // It is not necessary or efficient to use this function simply to avoid a call to
  // EventWrite. The EventWrite function will automatically perform an EventEnabled
  // check as its first operation.

  // This is unnecessary complexity and does not improve performance:
  // if (EventEnabled(regHandle, &myEventDesc))
  // {
  //     EventWrite(regHandle, &myEventDesc, ...);
  // }


  function EventEnabled(RegHandle: REGHANDLE;
                        const EventDescriptor: EVENT_DESCRIPTOR): BOOLEAN; stdcall;
  {$EXTERNALSYM EventEnabled}



//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Used to check whether any sessions are enabled to receive an event with the
  // given Level and Keyword.

  // Note that this function is not as efficient as the checks built into most
  // ETW frameworks (e.g. the checks implemented by mc.exe's generated code or by
  // TraceLoggingProvider.h). This function must look up the RegHandle state, while
  // the ETW frameworks can usually perform a direct check against global variables.
  // If using an ETW framework, use the framework's test APIs in preference to this
  // function.

  // This function can be used to avoid performing expensive preparation before
  // calling EventWrite, i.e. to avoid spending CPU cycles looking up data and
  // packing it into EVENT_DATA_DESCRIPTORs.

  // This is a good idea if PrepareEventData(...) is expensive:
  // if (EventProviderEnabled(regHandle, myEventDesc.Level, myEventDesc.Keyword))
  // {
  //     PrepareEventData(...);
  //     EventWrite(regHandle, &myEventDesc, ...);
  // }

  // It is not necessary or efficient to use this function simply to avoid a call to
  // EventWrite. The EventWrite function will automatically perform an EventEnabled
  // check as its first operation.

  // This is unnecessary complexity and does not improve performance:
  // if (EventProviderEnabled(regHandle, myEventDesc.Level, myEventDesc.Keyword))
  // {
  //     EventWrite(regHandle, &myEventDesc, ...);
  // }


  function EventProviderEnabled(RegHandle: REGHANDLE;
                                Level: UCHAR;
                                Keyword: ULONGLONG): BOOLEAN; stdcall;
  {$EXTERNALSYM EventProviderEnabled}



  // Writing (Publishing/Logging) APIs
  // =================================


//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Logs an ETW event.

  // Note that this function will use the implicit thread activity ID (from
  // thread-local storage) as the event's activity ID.

  // UserData may be NULL if UserDataCount is 0.

  // EventWrite(regHandle, &eventDesc, cData, pData) is equivalent to
  // EventWriteTransfer(regHandle, &eventDesc, NULL, NULL, cData, pData).


  function EventWrite(RegHandle: REGHANDLE;
                      const EventDescriptor: EVENT_DESCRIPTOR;
                      UserDataCount: ULONG;
                      UserData: EVENT_DATA_DESCRIPTOR): ULONG; stdcall;
  {$EXTERNALSYM EventWrite}



//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Logs an ETW event, optionally specifying activity IDs.
  //
  // If the ActivityId parameter is NULL, this function will use the implicit thread
  // activity ID (from thread-local storage) as the event's activity ID.
  //
  // If the RelatedActivityId parameter is NULL, the event will not include a
  // related activity ID.
  //
  // UserData may be NULL if UserDataCount is 0.
  //
  // EventWriteTransfer(regHandle, &eventDesc, pAI, pRAI, cData, pData) is equivalent to
  // EventWriteEx(regHandle, &eventDesc, 0, 0, pAI, pRAI, cData, pData).


  function EventWriteTransfer(RegHandle: REGHANDLE;
                              const EventDescriptor: EVENT_DESCRIPTOR;
                              const ActivityId: TGUID;
                              const RelatedActivityId: TGUID;
                              UserDataCount: ULONG;
                              UserData: EVENT_DATA_DESCRIPTOR): ULONG; stdcall;
  {$EXTERNALSYM EventWriteTransfer}


//#if (WINVER >= _WIN32_WINNT_WIN7)

  // Logs an ETW event, optionally specifying activity IDs, filter, and flags.
  //
  // The Filter parameter specifies sessions to which the event should not be
  // written. This should be set to 0 unless the provider is doing provider-size
  // filtering based on the FilterData parameter of the provider callback.
  //
  // The Flags parameter adds special behaviors to the event. Use EVENT_WRITE_FLAG
  // values, or 0 for no special behaviors.
  //
  // If the ActivityId parameter is NULL, this function will use the implicit thread
  // activity ID (from thread-local storage) as the event's activity ID.
  //
  // If the RelatedActivityId parameter is NULL, the event will not include a
  // related activity ID.
  //
  // UserData may be NULL if UserDataCount is 0.
  //
  // EventWriteTransfer(regHandle, &eventDesc, pAI, pRAI, cData, pData) is equivalent to
  // EventWriteEx(regHandle, &eventDesc, 0, 0, pAI, pRAI, cData, pData).


  function EventWriteEx(RegHandle: REGHANDLE;
                        const EventDescriptor: PCEVENT_DESCRIPTOR;
                        Filter: ULONG64;
                        Flags: ULONG;
                        const ActivityId: LPCGUID;
                        const RelatedActivityId: LPCGUID;
                        UserDataCount: ULONG;
                        UserData: EVENT_DATA_DESCRIPTOR): ULONG; stdcall;
  {$EXTERNALSYM EventWriteEx}



//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Writes a simple event containing a string.

  function EventWriteString(RegHandle: REGHANDLE;
                            Level: UCHAR;
                            Keyword: ULONGLONG;
                            const _String: LPCWSTR): ULONG; stdcall;
  {$EXTERNALSYM EventWriteString}


//#if (WINVER >= _WIN32_WINNT_VISTA)

  // Performs operations on activity IDs.

  // Use EVENT_ACTIVITY_CTRL values for the ControlCode parameter.

  // Depending on the ControlCode, this function does one or more of the following:
  //
  // - Generate a new activity ID.
  // - Get the implicit thread activity ID.
  // - Set the implicit thread activity ID.
  //
  // Generating an activity ID using this API is faster than generating a GUID with
  // UuidCreate. The IDs generated by this API are not GUIDs -- they are only
  // guaranteed to be unique on the local machine and only during the current boot
  // session.

  function EventActivityIdControl(ControlCode: ULONG;
                                  var ActivityId: TGUID): ULONG; stdcall;
  {$EXTERNALSYM EventActivityIdControl}



  // Initializes an EVENT_DATA_DESCRIPTOR with the given values.


  procedure EventDataDescCreate(out EventDataDescriptor: EVENT_DATA_DESCRIPTOR;
                                const DataPtr: PVOID;
                                DataSize: ULONG);
  {$EXTERNALSYM EventDataDescCreate}

  // Initializes an EVENT_DESCRIPTOR with the given values.
  procedure EventDescCreate(out EventDescriptor: EVENT_DESCRIPTOR;
                            Id: USHORT;
                            Version: UCHAR;
                            Channel: UCHAR;
                            Level: UCHAR;
                            Task: USHORT;
                            Opcode: UCHAR;
                            Keyword: ULONGLONG);
  {$EXTERNALSYM EventDescCreate}


  // Initializes an EVENT_DESCRIPTOR. Sets all values to 0.

  procedure EventDescZero(out EventDescriptor: EVENT_DESCRIPTOR);
  {$EXTERNALSYM EventDescZero}


  // Macros to extract info from an Event Descriptor
  // ===============================================

  function EventDescGetId(const EventDescriptor: EVENT_DESCRIPTOR): USHORT;

  function EventDescGetVersion(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;

  function EventDescGetTask(const EventDescriptor: EVENT_DESCRIPTOR): USHORT;

  function EventDescGetOpcode(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;

  function EventDescGetChannel(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;

  function EventDescGetLevel(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;

  function EventDescGetKeyword(const EventDescriptor: EVENT_DESCRIPTOR): ULONGLONG;



  // Macros to set info into an Event Descriptor
  // ===========================================

  function EventDescSetId(EventDescriptor: EVENT_DESCRIPTOR;
                          Id: USHORT): EVENT_DESCRIPTOR;

  function EventDescSetVersion(EventDescriptor: EVENT_DESCRIPTOR;
                               Version: UCHAR): EVENT_DESCRIPTOR;

  function EventDescSetTask(EventDescriptor: EVENT_DESCRIPTOR;
                            Task: USHORT): EVENT_DESCRIPTOR;

  function EventDescSetOpcode(EventDescriptor: EVENT_DESCRIPTOR;
                              Opcode: UCHAR): EVENT_DESCRIPTOR;

  function EventDescSetLevel(EventDescriptor: EVENT_DESCRIPTOR;
                             Level: UCHAR): EVENT_DESCRIPTOR;

  function EventDescSetChannel(EventDescriptor: EVENT_DESCRIPTOR;
                               Channel: UCHAR): EVENT_DESCRIPTOR;

  function EventDescSetKeyword(EventDescriptor: EVENT_DESCRIPTOR;
                               Keyword: ULONGLONG): EVENT_DESCRIPTOR;

  function EventDescOrKeyword(EventDescriptor: EVENT_DESCRIPTOR;
                              Keyword: ULONGLONG): EVENT_DESCRIPTOR;


  //Additional Prototypes for ALL interfaces
           {$WARN SYMBOL_PLATFORM OFF}
  //end of Additional Prototypes

implementation

  // Implement Additional Prototypes here.

const
  advapi32Lib = 'Advapi32.dll';

  // It's a good practice to use runtime linking (also use Delayed loading -if supported-).
  // This way, you avoid using conditional compilation, which makes installation
  // for different Win versions very complex. (ie you have to ship a different version of your
  // application for each Windows version) The "Delayed" option was introduced with Delphi 2010.

{$WARN SYMBOL_PLATFORM OFF}
  function EventRegister; external advapi32Lib name 'EventRegister' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventUnregister; external advapi32Lib name 'EventUnregister' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventSetInformation; external advapi32Lib name 'EventSetInformation' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventEnabled; external advapi32Lib name 'EventEnabled' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventProviderEnabled; external advapi32Lib name 'EventProviderEnabled' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventWrite; external advapi32Lib name 'EventWrite' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventWriteEx; external advapi32Lib name 'EventWriteEx' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventWriteTransfer; external advapi32Lib name 'EventWriteTransfer' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventWriteString; external advapi32Lib name 'EventWriteString' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
  function EventActivityIdControl; external advapi32Lib name 'EventActivityIdControl' {$IF COMPILERVERSION > 20.0} delayed {$ENDIF};
{$WARN SYMBOL_PLATFORM ON}


  // Macros to create Event and Event Data Descriptors
  // =================================================

  procedure EventDataDescCreate(out EventDataDescriptor: EVENT_DATA_DESCRIPTOR;
                                const DataPtr: PVOID;
                                DataSize: ULONG);
  begin
    EventDataDescriptor.Ptr := ULONGLONG(DataPtr);
    EventDataDescriptor.Size := DataSize;
    EventDataDescriptor.DUMMYSTRUCTNAME.Reserved:= 0;
  end;


  procedure EventDescCreate(out EventDescriptor: EVENT_DESCRIPTOR;
                            Id: USHORT;
                            Version: UCHAR;
                            Channel: UCHAR;
                            Level: UCHAR;
                            Task: USHORT;
                            Opcode: UCHAR;
                            Keyword: ULONGLONG);
  begin
    EventDescriptor.Id := Id;
    EventDescriptor.Version := Version;
    EventDescriptor.Channel := Channel;
    EventDescriptor.Level := Level;
    EventDescriptor.Task := Task;
    EventDescriptor.Opcode := Opcode;
    EventDescriptor.Keyword := Keyword;
  end;


  procedure EventDescZero(out EventDescriptor: EVENT_DESCRIPTOR);
  begin
    ZeroMemory(@EventDescriptor, sizeof(EVENT_DESCRIPTOR));
  end;


  // Macros to extract info from an Event Descriptor
  // ===============================================

  function EventDescGetId(const EventDescriptor: EVENT_DESCRIPTOR): USHORT;
  begin
    Result := EventDescriptor.Id;
  end;


  function EventDescGetVersion(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;
  begin
    Result := EventDescriptor.Version;
  end;


  function EventDescGetTask(const EventDescriptor: EVENT_DESCRIPTOR): USHORT;
  begin
    Result := EventDescriptor.Task;
  end;


  function EventDescGetOpcode(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;
  begin
    Result := EventDescriptor.Opcode;
  end;


  function EventDescGetChannel(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;
  begin
    Result := EventDescriptor.Channel;
  end;


  function EventDescGetLevel(const EventDescriptor: EVENT_DESCRIPTOR): UCHAR;
  begin
    Result := EventDescriptor.Level;
  end;


  function EventDescGetKeyword(const EventDescriptor: EVENT_DESCRIPTOR): ULONGLONG;
  begin
    Result:= EventDescriptor.Keyword;
  end;


  // Macros to set info into an Event Descriptor
  // ===========================================



  function EventDescSetId(EventDescriptor: EVENT_DESCRIPTOR;
                          Id: USHORT): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Id := Id;
    result:= EventDescriptor;
  end;


  function EventDescSetVersion(EventDescriptor: EVENT_DESCRIPTOR;
                               Version: UCHAR): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Version := Version;
    result:= EventDescriptor;
  end;


  function EventDescSetTask(EventDescriptor: EVENT_DESCRIPTOR;
                            Task: USHORT): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Task := Task;
    result:= EventDescriptor;
  end;


  function EventDescSetOpcode(EventDescriptor: EVENT_DESCRIPTOR;
                              Opcode: UCHAR): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Opcode := Opcode;
    result:= EventDescriptor;
  end;


  function EventDescSetLevel(EventDescriptor: EVENT_DESCRIPTOR;
                             Level: UCHAR): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Level := Level;
    result:= EventDescriptor;
  end;


  function EventDescSetChannel(EventDescriptor: EVENT_DESCRIPTOR;
                               Channel: UCHAR) : EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Channel := Channel;
    result:= EventDescriptor;
  end;


  function EventDescSetKeyword(EventDescriptor: EVENT_DESCRIPTOR;
                               Keyword: ULONGLONG): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Keyword := Keyword;
    result:= EventDescriptor;
  end;


  function EventDescOrKeyword(EventDescriptor: EVENT_DESCRIPTOR;
                              Keyword: ULONGLONG): EVENT_DESCRIPTOR;
  begin
    EventDescriptor.Keyword := EventDescriptor.Keyword or Keyword;
    result:= EventDescriptor;
  end;

end.
